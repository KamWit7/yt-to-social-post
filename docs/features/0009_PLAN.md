# Usage Limit Gate Feature Plan

## Feature Description

Implement a usage limit gate component that blocks users who have exceeded their free plan limit (set in `src/lib/actions/usage.ts`). This gate should be analogous to the existing `AuthGate` component but specifically for usage limits. When a user exceeds their limit, they should be informed about their free plan usage and redirected to the `/usage` page. The form state should be saved to sessionStorage before redirection, similar to how `AuthGate.tsx` handles authentication redirects.

## Technical Implementation

### Files to Create

1. **`src/components/dashboard/TranscriptionForms/forms/UsageGate/UsageGate.tsx`**
   - Main component that checks user usage limits
   - Displays usage limit exceeded UI with information about free plan
   - Handles form state saving to sessionStorage before redirect
   - Redirects to `/usage` route when limit exceeded and user click button

### Files to Modify

1. **`src/components/dashboard/TranscriptionForms/TranscriptionForms.tsx`**

   - Wrap `PurposeForm` with both `AuthGate` and `UsageGate` components
   - Update the PURPOSE case to include nested gate structure

2. **`src/utils/constants.ts`**
   - Add usage-related error messages
   - Add usage limit UI text constants

### Core Implementation Details

#### UsageGate Component Structure

- **Props**: `{ children: React.ReactNode }` (same as AuthGate)
- **State Management**: Uses `useSession()` for user authentication status
- **Usage Check**: Calls `getUserUsageStats()` from `src/lib/actions/usage.ts`
- **Form State Saving**: Uses `saveStateToSessionStorage()` with `TRANSCRIPTION_FORMS_STORAGE_KEY`
- **Context Integration**: Uses `useTranscriptionForms()` context for form state access

#### Usage Limit Check Algorithm

1. Get current session using `useSession()`
2. If no session, render children (let AuthGate handle auth)
3. If session exists, call `getUserUsageStats()` to get current usage
4. Check if `current >= limit` using existing usage logic
5. If within limits, render children
6. If exceeded, show usage limit UI and save form state

#### UI Design

- Similar visual structure to AuthGate but with usage-specific messaging
- Display current usage stats (e.g., "10/10 summaries used")
- Information about free plan limitations
- Primary action button: "View Usage Details" â†’ redirects to `/usage`
- Visual indicators: Usage meter or progress bar showing 100% usage

#### Form State Persistence

- Save identical state structure as AuthGate:
  ```typescript
  {
    transcript: formStepsState[DASHBOARD_TABS.TRANSCRIPT] || '',
    url: formStepsState[DASHBOARD_TABS.YOUTUBE] || '',
    activeTab,
    stepCompleted,
  }
  ```

### Integration Points

#### TranscriptionForms.tsx Updates

```typescript
case DASHBOARD_TABS.PURPOSE:
  return (
    <AuthGate>
      <UsageGate>
        <PurposeForm />
      </UsageGate>
    </AuthGate>
  )
```

#### Constants.ts Additions

- `USAGE_LIMIT_MESSAGES`: Error and informational messages
- `USAGE_GATE_TEXT`: UI text for the usage gate component

### Error Handling

- Handle loading states while checking usage
- Handle API errors when fetching usage stats
- Fallback to allowing access if usage check fails (fail-open approach)
- Display appropriate error messages for different failure scenarios

### Dependencies

- Reuses existing `getUserUsageStats()` function from `src/lib/actions/usage.ts`
- Leverages existing `saveStateToSessionStorage()` utility
- Uses existing `useTranscriptionForms()` context
- Integrates with existing session management via `next-auth`

## Implementation Order

1. Create `UsageGate.tsx` component with usage checking logic
2. Add required constants to `constants.ts`
3. Update `TranscriptionForms.tsx` to integrate UsageGate
4. Test integration with existing AuthGate flow
5. Verify form state persistence works correctly
