# Plan techniczny: Uwierzytelnianie i Zarządzanie Użytkownikami (Etap 2)

## Opis

Implementacja systemu uwierzytelniania za pomocą NextAuth.js, integracja z bazą danych PostgreSQL z Prisma ORM, oraz wprowadzenie modelu użytkownika z limitami użycia darmowych podsumowań. System będzie podzielony na dwie fazy: warstwa danych i implementacja uwierzytelniania.

Zgodnie z wymaganiami z TODOT.md:

- **Logowanie**: Integracja systemu uwierzytelniania (NextAuth.js)
- **Baza Danych**: Podłączenie do bazy danych PostgreSQL
- **Model Użytkownika**: Tabela `User` powiązana z systemem logowania
- **Limity Użycia**: Logika śledzenia i ograniczania darmowych podsumowań dla zalogowanych użytkowników

## Faza 1: Warstwa Danych - Baza Danych i Schema

### Nowe pliki do stworzenia:

#### Backend - Baza danych i ORM

- `/backend/prisma/schema.prisma` - Schema bazy danych Prisma
- `/backend/prisma/migrations/` - Migracje bazy danych
- `/backend/.env.example` - Przykładowy plik środowiskowy z DATABASE_URL
- `/backend/src/lib/prisma.ts` - Konfiguracja klienta Prisma
- `/backend/src/middleware/auth.middleware.ts` - Middleware weryfikacji JWT dla backendu
- `/backend/src/services/user.service.ts` - Serwis operacji użytkowników
- `/backend/src/controllers/user.controller.ts` - Kontroler endpointów użytkowników
- `/backend/src/routes/user.routes.ts` - Routing dla operacji użytkowników
- `/backend/src/validations/user.validations.ts` - Walidacja Zod dla operacji użytkowników
- `/backend/src/types/user.types.ts` - Typy TypeScript dla użytkowników

#### Frontend - NextAuth.js i integracja

- `/yt-scribe/.env.example` - Przykładowy plik środowiskowy z NEXTAUTH_SECRET
- `/yt-scribe/src/lib/auth.ts` - Konfiguracja NextAuth.js
- `/yt-scribe/src/app/api/auth/[...nextauth]/route.ts` - API Route dla NextAuth.js (App Router)
- `/yt-scribe/src/components/auth/LoginForm.tsx` - Komponent formularza logowania
- `/yt-scribe/src/components/auth/RegisterForm.tsx` - Komponent formularza rejestracji
- `/yt-scribe/src/components/auth/AuthProvider.tsx` - Provider do wrappowania aplikacji
- `/yt-scribe/src/components/common/UserMenu.tsx` - Menu użytkownika w headerze
- `/yt-scribe/src/middleware.ts` - Middleware NextAuth.js dla ochrony tras
- `/yt-scribe/src/hooks/useAuth.ts` - Hook do zarządzania stanem uwierzytelniania
- `/yt-scribe/src/api/services/userService.ts` - Serwis API dla operacji użytkowników

### Pliki do modyfikacji:

#### Backend

- `/backend/package.json` - Dodanie zależności: `prisma`, `@prisma/client`, `jsonwebtoken`, `@types/jsonwebtoken`, `bcrypt`, `@types/bcrypt`
- `/backend/src/server.ts` - Rejestracja tras użytkowników
- `/backend/src/routes/ai.routes.ts` - Dodanie middleware auth do endpointów AI
- `/backend/src/services/ai-processing.service.ts` - Integracja z limitami użycia
- `/backend/src/controllers/ai.controller.ts` - Sprawdzanie limitów przed przetwarzaniem

#### Frontend

- `/yt-scribe/package.json` - Dodanie zależności: `next-auth`, `@next-auth/prisma-adapter`
- `/yt-scribe/src/app/layout.tsx` - Dodanie AuthProvider
- `/yt-scribe/src/components/common/Header.tsx` - Integracja UserMenu
- `/yt-scribe/src/app/login/page.tsx` - Strona logowania
- `/yt-scribe/src/app/register/page.tsx` - Strona rejestracji
- `/yt-scribe/src/components/dashboard/TranscriptionForms/forms/PurposeForm/PurposeForm.tsx` - Dodanie user context do requestów AI
- `/yt-scribe/src/types/index.ts` - Dodanie typów dla User i Auth

## Faza 2A: Backend - JWT Authentication i User Management

### Schema Bazy Danych (PostgreSQL z Prisma)

```prisma
// backend/prisma/schema.prisma
model User {
  id               String   @id @default(cuid())
  email            String   @unique
  password         String   // bcrypt hashed
  name             String?
  encryptedApiKey  String?  // dla BYOK w przyszłości (Etap 3)
  usageCount       Int      @default(0)
  maxFreeUsage     Int      @default(10) // limit darmowych użyć
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations for NextAuth.js
  accounts Account[]
  sessions Session[]

  @@map("users")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
```

### Backend API Endpoints

#### Endpointy uwierzytelniania:

- `POST /api/auth/register` - Rejestracja użytkownika (email, hasło, nazwa)
- `POST /api/auth/login` - Logowanie użytkownika (email, hasło) → zwraca JWT
- `POST /api/auth/refresh` - Odświeżanie tokena JWT

#### Endpointy użytkowników:

- `GET /api/users/profile` - Pobranie profilu użytkownika [wymagana autoryzacja]
- `PUT /api/users/profile` - Aktualizacja profilu użytkownika [wymagana autoryzacja]
- `GET /api/users/usage` - Sprawdzenie stanu użycia (usageCount/maxFreeUsage) [wymagana autoryzacja]

### Algorytm Limitów Użycia

1. **Sprawdzenie autoryzacji**: Middleware `auth.middleware.ts` weryfikuje token JWT i dodaje `user` do `req.user`
2. **Sprawdzenie limitów**: W `ai.controller.ts` przed przetwarzaniem:
   - Jeśli użytkownik niezalogowany → ograniczenie IP (istniejące rate limiting)
   - Jeśli użytkownik zalogowany:
     - Sprawdź `user.usageCount < user.maxFreeUsage`
     - Jeśli limit przekroczony → błąd 403 "Limit darmowych użyć wyczerpany"
     - Jeśli OK → kontynuuj przetwarzanie
3. **Aktualizacja licznika**: Po udanym przetwarzaniu zwiększ `user.usageCount++` w bazie
4. **Obsługa błędów**: Logowanie prób przekroczenia limitów

### Szyfrowanie haseł

- Użycie `bcrypt` z salt rounds = 12
- Hash podczas rejestracji w `user.service.ts`
- Weryfikacja podczas logowania w `user.service.ts`

## Faza 2B: Frontend - NextAuth.js Integration

### Konfiguracja NextAuth.js

```typescript
// yt-scribe/src/lib/auth.ts
export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        // Wywołanie do backend API /auth/login
        // Zwrócenie user object lub null
      },
    }),
    GoogleProvider({
      // opcjonalnie dla OAuth
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  session: { strategy: 'jwt' },
  pages: {
    signIn: '/login',
    signUp: '/register',
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.usageCount = user.usageCount
        token.maxFreeUsage = user.maxFreeUsage
      }
      return token
    },
    async session({ session, token }) {
      session.user.id = token.sub
      session.user.usageCount = token.usageCount
      session.user.maxFreeUsage = token.maxFreeUsage
      return session
    },
  },
}
```

### Komponenty UI

#### LoginForm / RegisterForm

- Użycie `react-hook-form` z walidacją Zod
- Styled z `shadcn/ui` komponenty (Input, Button, Card)
- Obsługa błędów walidacji i błędów serwera
- Loading states podczas submitowania

#### UserMenu

- Dropdown menu w headerze (wykorzystanie Radix UI)
- Wyświetlanie email użytkownika i licznika użyć
- Opcje: Profil, Wyloguj
- Wskaźnik progress bar dla limitów użycia

### Ochrona tras

```typescript
// yt-scribe/src/middleware.ts
import { withAuth } from 'next-auth/middleware'

export default withAuth(
  function middleware(req) {
    // Middleware logic
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token,
    },
  }
)

export const config = {
  matcher: [
    '/dashboard/:path*', // tylko zalogowani użytkownicy
  ],
}
```

### Integracja z istniejącymi formularzami

- W `PurposeForm.tsx` dodanie user context do API requestów
- Wyświetlanie aktualnego stanu limitów w UI
- Blokowanie submitowania gdy limit przekroczony
- Komunikaty o konieczności logowania dla gości

## Zmienne środowiskowe

### Backend (`/backend/.env`)

```bash
DATABASE_URL="postgresql://username:password@localhost:5432/ytscribe"
JWT_SECRET="your-super-secret-jwt-key"
JWT_REFRESH_SECRET="your-refresh-secret-key"
BCRYPT_SALT_ROUNDS=12
```

### Frontend (`/yt-scribe/.env.local`)

```bash
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-nextauth-secret-key"
NEXT_PUBLIC_BACKEND_URL="http://localhost:8000"

# OAuth (opcjonalnie)
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
```

## Kroki implementacji

### Faza 1: Baza danych

1. Backend: Zainstaluj Prisma i skonfiguruj schema
2. Utwórz migracje i uruchom `prisma generate`
3. Dodaj klient Prisma do serwisów

### Faza 2A: Backend Auth

4. Implementuj user service z operacjami CRUD
5. Stwórz auth middleware z weryfikacją JWT
6. Dodaj kontrolery i routing dla użytkowników
7. Integruj sprawdzanie limitów do AI controller

### Faza 2B: Frontend Auth

8. Zainstaluj i skonfiguruj NextAuth.js
9. Stwórz komponenty logowania/rejestracji
10. Dodaj AuthProvider do aplikacji i ochronę tras
11. Zintegruj user menu z headerem
12. Połącz formularze AI z user context

### Testing & QA

13. Testy integracyjne endpointów uwierzytelniania
14. Testy limitów użycia i edge cases
15. QA flow: rejestracja → logowanie → używanie AI → limity

## Potencjalne ryzyka

- **Migracje bazy**: Upewnij się, że są atomiczne i da się je wycofać
- **Session management**: NextAuth.js z JWT może wymagać ręcznej synchronizacji stanu limitów
- **Security**: Validate JWT tokens properly, use HTTPS in production
- **UX**: Graceful handling gdy user session expires podczas długotrwałej operacji AI
