# Feature Plan: BYOK (Bring Your Own Key) Implementation

## Context

Implement BYOK (Bring Your Own Key) functionality that allows users to provide their own Google Gemini API key instead of using the application's shared API key. Users with BYOK tier will have unlimited usage and their API keys will be encrypted and stored securely in the database.

## Technical Requirements

- **Settings UI**: User interface for entering and managing Google Gemini API key
- **Encryption**: Secure storage of API keys using existing encryption utilities
- **Tier Management**: Server action to save API key and upgrade user from `free` to `BYOK` tier
- **API Integration**: Use user's own API key when processing AI requests for BYOK users
- **Security**: All API keys encrypted at rest, clear user information about data security

## Files and Functions to Modify/Create

### Phase 1: Settings UI Implementation

#### Settings Page (`src/app/(user)/settings/page.tsx`)

- Create comprehensive settings page with BYOK section
- Display current tier status (free vs BYOK)
- Form for API key input with validation
- Information section about Google Gemini API key requirements
- Security reassurance about encryption
- Instructions on how to obtain Google Gemini API key

#### New Components (`src/components/settings/`)

- **ApiKeyForm**: Form component for API key input and validation
- **TierStatus**: Component showing current user tier and benefits
- **ApiKeyInstructions**: Component with detailed instructions for obtaining Gemini API key
- **SecurityInfo**: Component explaining encryption and data security

### Phase 2: Server Actions and Database Operations

#### Tier Management Action (`src/lib/actions/tier.ts`)

- `saveApiKeyAndUpgradeTier(apiKey: string)`: Server action to:
  1. Validate the provided API key format
  2. Test API key validity with a simple Gemini API call
  3. Encrypt the API key using existing encryption utility
  4. Update user's `UserUsage` record with encrypted API key
  5. Change user's `accountTier` from `free` to `BYOK`
  6. Return success/error response

#### Database Utilities (`src/lib/db/usage.ts`)

- `updateUserApiKey(userId: string, encryptedApiKey: string)`: Update user's API key
- `upgradeUserTier(userId: string, tier: AccountTier)`: Change user's account tier
- `getUserApiKey(userId: string)`: Retrieve and decrypt user's API key

### Phase 3: API Integration Updates

#### AI Processing Service Updates (`src/api/services/aiProcessingService.ts`)

- Modify `processWithAI` to check user's tier
- For BYOK users, use their decrypted API key instead of system key
- Maintain backward compatibility for free tier users

#### Usage Tracking Updates (`src/lib/actions/usage.ts`)

- Modify `trackUserUsage` to skip usage limits for BYOK users
- Update usage tracking logic to differentiate between tiers

#### Environment Configuration (`src/lib/env/server.ts`)

- Add optional `GEMINI_API_KEY` for system-wide usage (free tier)
- Ensure encryption key is available for API key encryption/decryption

## Implementation Algorithm

### API Key Validation and Storage Flow

1. User enters API key in settings form
2. Client-side validation (format, length)
3. Server action receives API key
4. Test API key with simple Gemini API call to verify validity
5. If valid, encrypt API key using `encrypt()` from `utils/encryption.ts`
6. Store encrypted API key in `UserUsage.apiKey` field
7. Update `UserUsage.accountTier` to `BYOK`
8. Return success response to client

### AI Processing Flow for BYOK Users

1. User initiates AI processing request
2. Check user's `accountTier` in database
3. If `BYOK`:
   - Retrieve encrypted API key from `UserUsage.apiKey`
   - Decrypt using `decrypt()` from `utils/encryption.ts`
   - Use decrypted API key for Gemini API calls
   - Skip usage limit checks
4. If `free`:
   - Use system Gemini API key
   - Apply usage limit checks as before

### Settings UI Flow

1. Load current user tier and API key status
2. Display appropriate UI based on tier:
   - Free tier: Show upgrade form and benefits
   - BYOK tier: Show current status and option to update key
3. Handle API key form submission with validation
4. Show success/error messages and update UI accordingly

## File Structure Changes

```
src/
├── app/
│   └── (user)/
│       └── settings/
│           └── page.tsx                    # Main settings page
├── components/
│   └── settings/
│       ├── ApiKeyForm.tsx                  # API key input form
│       ├── TierStatus.tsx                  # Current tier display
│       ├── ApiKeyInstructions.tsx          # Gemini API setup guide
│       └── SecurityInfo.tsx               # Encryption info
├── lib/
│   ├── actions/
│   │   └── tier.ts                         # BYOK server actions
│   └── db/
│       └── usage.ts                        # Updated with API key methods
└── types/
    └── settings.ts                         # Settings-related types
```

## Integration Points

### Existing Components to Update

- **AI Processing Pipeline**: Check user tier and use appropriate API key
- **Usage Tracking**: Skip limits for BYOK users
- **Navigation**: Add settings link if not present

### Database Schema

- **UserUsage Model**: Already has `apiKey` and `accountTier` fields
- **No schema changes required**: Existing structure supports BYOK

### Security Considerations

- **Encryption**: Use existing `encrypt/decrypt` functions with `API_ENCRYPTION_KEY`
- **API Key Validation**: Test keys before storage to prevent invalid keys
- **Access Control**: Ensure only authenticated users can access settings
- **Error Handling**: Don't expose API key values in error messages

## User Experience Flow

### First-time BYOK Setup

1. User navigates to Settings page
2. Sees current "Free" tier status and limitations
3. Reads instructions on obtaining Google Gemini API key
4. Enters API key in secure form
5. System validates key and upgrades tier
6. User sees confirmation and new "BYOK" status

### BYOK User Experience

1. Unlimited AI processing (no usage counter)
2. Settings page shows "BYOK" status
3. Option to update API key if needed
4. Clear indication that their own API key is being used

## Dependencies

This feature depends on:

- Existing authentication system (NextAuth.js)
- Database schema with `UserUsage` model
- Encryption utilities in `utils/encryption.ts`
- Current AI processing pipeline

## Validation Requirements

### API Key Validation

- Format validation (Google API key pattern)
- Functional validation (test API call to Gemini)
- Error handling for invalid/expired keys

### Security Validation

- Encryption/decryption round-trip testing
- Access control verification
- API key masking in UI (show only last 4 characters)
